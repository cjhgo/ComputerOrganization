viewport:width=device-width,initial-scale=1

目录

[TOC]
#[计算机组成原理](...)
##Ch3输入输出系统
重点分析i/o设备和主机交换信息的三种控制方式
(实际上还有两种,在体系结构中介绍)

###1.概述

####输入输出系统发展的4个阶段
1. 早期阶段
2. 接口模块和DMA模块
	- 接口中设有数据通路和控制通路;
	数据通路:可以缓存数据,完成串并转换;控制通路用以传送CPU和i/o设备之间的命令
		+ 使用接口实现主机和i/o设备交换信息时CPU要中断
	- DMA,在i/o设备和主存之间有一条直接数据通路,CPU不用中断
3. 具有通道结构的阶段
4. 具有i/o处理机的阶段

####输入输出系统的组成
**输入输出系统由I/O软件和I/O硬件两部分组成**

+ I/O指令
+ 通道指令
####I/O设备与主机的联系方式

1. I/O设备编址方式
	+ 独立编址
	+ 统一编址
2. 设备寻址
	+ 通过接口电路中的设备选择电路选中要交换信息的设备
3. 传送方式
	+ 并行:速度快,要求较多数据线
	+ 串行:速度慢,适合远距离传送
4. 联络方式
	+ 立即响应,无须特殊的联络信号,指令一道立即响应,,,,,,????
	+ 异步工作,采用应答信号联络
	+ 同步工作,采用同步时标联络
5. 连接方式
	+ 总线式
	+ 辐射式
####I/O设备与主机信息传送的控制方式

1. 程序查询
2. 程序中断
3. 直接存储器存取方式(DMA)
4. I/O通道方式
5. I/O处理机方式
(1,2,3详见后边,4,5不具体讲述)

###2.I/O设备
,,,,,,,,,,??????????/
键盘,显示器,打印机这三种设备如何与主机联系,?
###3.I/O接口
,,,,,,,,,,?????????
###4.程序查询方式
核心问题:**每时每刻不断查询I/O设备是否准备就绪**

####程序查询流程
+ 单个I/O设备的查询流程
	+ 程序流程
		1. 由于传送数据需要占用CPU的寄存器,所以**保护寄存器**内容
		2. 由于传送的往往是一批数据,所以**设置计数值**
		3. 设置欲传送数据的首地址
		4. CPU启动i/o设备
		5. 进入程序查询流程:
			- test:准备就绪,?
				+ 就绪:数据传送
				+ 未就绪:接着test
		6. 完成一次数据传送后,修改主存地址,修改计数值,
		7. 判断计数值,看传送是否完毕
		8. 结束i/o传送
+ 多个I/O设备的查询流程:
	- 按设备在系统中的优先级别进行逐级查询

为完成查询,通常需要3条指令

+ 测试指令
+ 传送指令
+ 转移指令

####程序查询方式的接口电路

+ 输出$\quad CPU\rightarrow i/o接口 \rightarrow i/o设备$
+ 输入$\quad CPU\leftarrow i/o接口 \leftarrow i/o设备$

###5.程序中断方式
**主要介绍i/o中断处理的相关内容**

####程序中断方式的接口电路

#####中断请求触发器和中断屏蔽触发器

1. 中断请求触发器和中断屏蔽触发器
	- 每台外设设置一个中断请求触发器INTR,为1时,表示设备箱CPU提出中断请求
		+ 设备要想提出中断请求,本身必须准备就绪,所以设置一个完成触发器D,表示设备的状态
		+ 当多个中断源同时向CPU提出中断请求时,CPU要坚持一个原则,任何瞬间只能接受一个中断源的请求
		所以每个i/o接口需设置一个屏蔽触发器MASK,当其为1时,表示被屏蔽
		+ CPU在统一的时间-每条指令执行阶段的最后时刻-查询所有设备是否有中断请求
			- (只针对外中断,是这个时刻,内中断肯定要及时响应)
		+ 综上:CPU的中断查询信号将中断请求触发器置1的条件
		(也就是说,外设提出中断,未必会被满足,CPU不一定能将中断请求出发器置1,
		也就是说,中断请求触发器置1,不是说外设提出了中断,而是说CPU满足中断请求)
			+ 设备就绪,即完成触发器为1
			+ 没有被屏蔽,
![接口发出中断请求的条件][0]		
[0]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/INTR.gif
解读:在<u>设备就绪</u>且<u>没有被屏蔽</u>的情况下,当CPU的中断查询信号传来时,接口发出了中断请求信号
(这个信号输出到排队器里边去,参与排队)
#####排队器

2. 排队器:多个中断源同时提出请求时,按优先级高低给予响应,**速度越高优先级越高**
(因为如果不及时响应速度高的设备,它的信息可能会立即消失)
优先权处理可用硬件方法,软件方法,
	+ 软件方法:编写程序查询
	+ 硬件方法:硬件排队器(链式排队器)
		- 在CPU内部设置一个统一的排队器
		![CPU内的链式排队器][1]
		排队原理:
		$INTP_i=\overline{INTP_0}\cdot\overline{INTP_1}\cdots\overline{INTP_{i-1}}\cdot INTR_i\\\
		=\overline{(INTP_{0}+INTP_{1}+\cdots+INTP_{i-1})}\cdot INTR_i,记为\overline{A}\cdot INTR_i\\\
		可见,欲使排队器输出端第i级输出为1,当且仅当A=0\&INTR_i=1,\\\
		A=0,即比第i级高的排队器输出端皆为0,\\\
		反之,只要第i级排队器输出端为1,则\\\
		比第i级优先级级别低的i+1,i+2...级输出皆为0$
		- 在接口电路内分别设置各个设备的排队器
		![分设的链式排队器][2]
		排队原理:
		$INTP_i=INTR_i\cdot INTP_i'\\\
		INTP_i'=\overline{INTR_{i-1}}\cdot NTP_{i-1}' (i>1,INTP_1'=1)\\\
		INTP_i=\overline{(INTR_0+INTR_1+\cdots+INTR_{i-1})}\cdot INTR_i\cdot INTP_1'\\\
		记为\overline{B}\cdot INTR_i \cdot 1\\\
		可见,欲使排队器输出端第i级输出为1,当且仅当B=0\&INTR_i=1,\\\
		B=0,即比第i级高的设备的中断请求输出皆为0,\\\
		反之,只要第i级有中断请求输出,则\\\
		比第i级优先级级别低的i+1,i+2...级排队输出皆为0$
[1]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/chainqueueofcpu.gif
[2]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/chainqueue.gif
#####中断向量地址形成部件(设备编码器)

3. 中断向量地址形成部件(设备编码器)
响应中断就要去执行对应的中断服务程序.CPU如何找到中断服务程序的入口地址,?
	+ 软件查询法:
	+ 硬件向量法:通过向量地址来寻找中断服务程序的入口地址,
	**而向量地址是由硬件电路产生**
		+ 对应于链式排队器的两种放法,中断向量地址形成部件也有两种放法
			- 分散设置在各个接口电路中
			- 放置在CPU内部
		+ 由向量地址寻找中断服务程序入口地址通常也采用两种放法
			- 向量地址内存存放一条无条件转义指令(**向量地址转移**),向量地址送PC
				+ 据白中英说:这种方法允许中断处理程序放在内存中的任何地方,非常灵活
			- 向量地址内存存放入口地址(**设置向量地址表**),访存得到入口地址
			**区别在于一个放的是指令,一个放的是地址**
	+ 分清**向量地址**和中断服务程序入口地址**的区别
#####程序中断接口电路基本组成
电路图
![补图][图5.41]
####i/o中断处理过程

1. CPU响应中断的条件和时间
	+ 条件:'开中断'
	+ 时间:每条指令执行阶段的结束时刻,发出中断查询信号
2. i/o中断处理过程
	+ 中断请求,中断判优,中断响应,中断服务,中断返回
####中断服务程序的流程

1. 保护现场
	+ 保护程序的断点
		- 由中断隐指令完成
	+ 保存通用寄存器和状态寄存器的内容
		- 由中断服务程序完成
2. 中断服务
3. 恢复现场
	+ 用取数指令或出栈指令将保存在存储器或堆栈中的信息送到原来的寄存器中
4. 中断返回
	+ 中断服务程序的最后一条指令,通常是一条中断返回指令,**使pc返回到原程序断点处**

中断服务的细节,单重中断,多重中断的问题,见接下来的Ch8.4

主存和外设交换信息,在程序中断方式中,

+ 相较于程序查询方式,CPU不再踏步等待,实现了CPU和i/o的并行工作,调高了CPU的资源利用率
+ 但是,CPU在处理中断服务程序时,仍需暂停原程序,当高速i/o与主存频繁的交换信息时,采用程序中断方式不断的打断CPU
执行主程序,为此,人们探索出效率更高的DMA控制方式

###6.DMA方式
####DMA方式的特点

不通过CPU交换信息,不暂停CPU,

#####CPU和DMA访存冲突的三种解决方法
由于DMA和CPU共享主存,当出现两者争用主存的冲突时,有三种解决措施

+ 停止CPU访存:
	- DMA接口向CPU发停止信号,要求CPU放弃总线使用权;
	DMA获取总线控制权后,传送数据;
	传送完毕后通知CPU可以使用主存,并交回总线控制权
	- 优点:控制简单;缺点:效率低
	(这什么破方法,,,还不如程序查询吧,,,)
+ 周期挪用
	- i/o设备发出DMA请求时,挪用或窃取总线占有权一个或几个主存周期;不请求时,CPU继续访存
	- 请求DMA时CPU的三种可能状态
		+ 在执行指令,不访存,此时不发生冲突
		+ CPU正在访存,**待存取周期结束后**,CPU让出总线占有权
		+ CPU也正要求访存,**出现冲突**的情况:i/o访存优先于CPU访存;CPU在执行访存的指令插入几个周期,延缓访存
	- 比较适合于i/o设备读写周期大于主存周期的情况
+ DMA与CPU交替访问
	- 将一个CPU周期分成两个周期,,???
	- 不用总线使用权的申请,建立,归还过程
	- 比较适合于CPU工作周期比主存周期长的情况
####DMA接口的功能和组成

#####功能
+ 向CPU申请DMA传送	
+ 处理总线交接
+ 在DAM期间控制数据传送
+ 确定,修改数据传送的起始地址和长度
+ 数据传送介绍时,向cpu给出操作完成的额信号
#####基本组成

+ 主存地址寄存器AR:数据在内存中的首地址,每交换一次数据改变一次
+ 字节数器WC:记录传送数据的总字数;补码表示,原码表示;
+ 数据缓冲寄存器BR:用于暂存每次传送的数据
	- 通常DMA接口与主存之间采用字传送,DMA和设备之间可能是字节或位传送
+ DMA控制逻辑
+ 中断机构:字计数器溢出时,一批数据交换完毕,有溢出信号通过中断机构向CPU提中断请求
+ 设备地址寄存器DAR
####DMA的工作过程

#####数据传送过程
1. 数据传送过程
	+ **预处理**:在DMA开始工作之前,cpu必须给它配置如下信息
		- 给DMA控制逻辑指明数据传送方向,是输入(写主存)还是输出(读主存)
		- 向DMA设备地址寄存器送设备号,启动设备
		- 送主存起始地址到设备地址寄存器
		- 送数据个数到字计数器
	之后cpu继续执行原来的程序,在cpu继续执行原来程序的同时,外设也在准备以待输入进内存的数据
	+ **数据传送**:设备向DMA发请求,DMA向cpu法总线控制请求
	(设备什么时候发请求,?)
		- 数据输入(到主存):
			+ 当设备准备好一个字时将改字读到DMA的BR中
				- **BR已满时,设备向DMA接口发请求DREQ**
			+ DMA接口向CPU申请总线控制权HRQ
			+ CPU发回HLDA信号,表示允许将总线控制权交给DMA接口
			+ ...
		- 数据输出(到外设)
			+ 当DMA的BR已将输出数据送至i/o设备后,
				- **BR已空时,设备向DMA接口发请求**
			+ DMA接口向CPU申请总线控制权HRQ
			+ CPU发回HLDA信号,表示允许将总线控制权交给DMA接口
			+ ...,?
	+ **后处理**:当DMA的中断请求得到响应时,CPU停止原程序的执行,准去执行中断服务程序
	做一些DMA的结束工作包括
		+ 校验送入主存的数据
		+ 是否继续用DMA传送其他数据块
			- 若继续则要再次初始化DMA接口
			- 若不再继续,则要停止外设
		+ 测试传送过程有无错误,
#####DMA接口与系统的连接方式
2. DMA接口与系统的连接方式
	+ 具有公共请求线的DMA请求
		- 若干个dma接口通过一条公用的dma请求线向cpu申请总线控制权;
		cpu发响应信号,链式查询,首先选中的获得控制权
	+ 独立的DMA请求
		- 每一个dma接口各有一对独立的dma请求线和响应线;
		cpu的优先级判别机构裁决首先响应哪个请求,然后在对应的响应线上发出响应信号
#####DMA小结(与程序中断方式的比较)
3. DMA小结(与程序中断方式的比较)
	+ 从数据传送看,
	(**DMA传送是由硬件代替软件实现数据直接传送**
	为什么这么说:由dma控制器这个硬件来完成改内存,改计数器这些任务;
	在中断方式中这些事情是由中断服务程序的代码来完成的
	)
		- 程序中断方式靠程序传送,
		- dma方式靠硬件传送
	+ 从cpu响应时间看,
		- 程序中断方式时,cpu在每条指令执行结束时发中断查询信号
		- dma方式时,cpu在指令周期内的任意存取周期结束时检测有无dma请求HRQ
	+ 程序中断有处理异常事件的能力,dma没有这种能力
	dma主要用于大批量数据的传送
	+ 程序中断方式需要中断现行程序,故需保护现场;dma不中断现行程序,无须保护现场;
	+ dma的优先级比程序中断优先级要高
####DMA的接口类型
#####选择型dma接口
+ **物理上可连接多个设备,逻辑上只允许连接一个设备**
即:在某一段时间内,dma接口只能为一个设备服务
+ 适用于数据传输率很高的设备
#####多路型dma接口	
+ **物理上可连接多个设备,逻辑上也允许多个设备同时工作**
各个设备通过采用字节交叉的方式通过dma接口进行数据传送
**为每个设备设置了一套寄存器**
+ 适合于同时为多个数据传输率不高的设备服务
##Ch8CPU的结构与功能
###4.中断系统
####1.概述
#####引起中断的各种因素
1. 自愿中断
2. 程序性事故
3. 硬件故障
4. i/o设备
5. 外部事件
**中断源**:将因为中断的各个因素称为中断源

+ 不可屏蔽中断:cpu不能禁止响应
+ 可屏蔽中断:根据中断源是否被屏蔽来确定是否给予响应
#####中断系统需要解决的问题
1. 各中断源如何向cpu提中断请求
	- 通过中断接口发INTR请求
2. 多个中断源同时提请求时,中断系统如何确定优先响应哪个中断源的请求
	- 通过排队器
3. cpu在什么条件,什么时候,以什么方式响应中断
	- 在cpu开中断的条件下
	- 在每条指令执行结束时,
	- 发中断查询信号,
4. 响应中断后,如何保护现场(从而能在中断服务程序结束后恢复现场)
	- 中断隐指令,负责保护断点
5. 响应中断后,如何停止原程序的执行,转入中断服务程序(如何得到中断服务程序地址)
	- 硬件向量法
	- 软件查询法
6. 中断处理结束后,如何恢复现场,返回原程序的间断处,?
	- 有中断服务程序完成
7. 中断处理过程中,出现新的中断请求,cpu如何处理
	- 单重中断,禁止响应新的中断请求
	- 多重中断,响应优先级高的请求
#####中断请求标记和中断判优逻辑
(触发器集中设置变成为寄存器)

+ 中断请求标记:判断是哪个中断源提出请求
	- 集中在cpu的中断系统内
	- 分散在各个接口电路内
+ 中断判优逻辑(详见输入输出)
	- 软件方法,软件排队
	- 硬件方法,硬件排队
#####中断服务入口程序地址的寻找
+ 硬件向量法
+ 软件查询法
#####中断响应
1. 响应条件:开中断,EINT为1,允许中断触发器
2. 响应时间:指令的执行周期后进入中断周期
	+ 如果某些指令执行时间很长,可在指令执行过程中设置"查询断点"
3. 中断隐指令
(机器指令系统中没有的指令,cpu在中断周期内由硬件自动完成的一条指令)
	+ 保护断点:PC内容保存到堆栈/存储器特定单元
	+ 寻找中断服务程序的入口地址
	中断周期结束后就进入下条指令(中断服务程序的第一条指令)的取指周期,所以必须在中断周期内找到入口地址
		- 对应于硬件向量法,向量地址送PC,通过无条件转移指令进入中断服务程序
		- 对应于软件查询法,中断识别程序首地址送PC,由中断识别程序进入中断服务程序
	+ 关中断:为确保,不被干扰,
#####保护现场和恢复现场
保护现场有两方面,分别由中断隐指令和中断服务程序完成
恢复现场由中断服务程序完成
#####中断屏蔽技术(用于多重中断)	
+ 实现中断嵌套的条件
	- 提前设置开中断指令:
		+ 多重中断:保护现场后开中断
		+ 单重中断:恢复现场后开中断
	- 优先级别高的中断源有权中断优先级别低的中断源
	- 屏蔽技术(保证级别低的中断源不干扰级别高的中断源的中断处理过程)
	**不具有屏蔽功能的排队器,保护现场后开了中断,则只要有中断在此请求,cpu就会响应**
	**这样无论级别高低,是个中断请求就能中断当前的中断服务程序**
	**所以,为排队器加上屏蔽功能,使级别低的中断请求无法中断当前中断服务,级别高的中断请求则可以**