viewport:width=device-width,initial-scale=1

目录

[TOC]
#[计算机组成原理](...)
##Ch3输入输出系统
重点分析i/o设备和主机交换信息的三种控制方式
(实际上还有两种,在体系结构中介绍)

###1.概述

####输入输出系统发展的4个阶段
1. 早期阶段
2. 接口模块和DMA模块
	- 接口中设有数据通路和控制通路;
	数据通路:可以缓存数据,完成串并转换;控制通路用以传送CPU和i/o设备之间的命令
		+ 使用接口实现主机和i/o设备交换信息时CPU要中断
	- DMA,在i/o设备和主存之间有一条直接数据通路,CPU不用中断
3. 具有通道结构的阶段
4. 具有i/o处理机的阶段

####输入输出系统的组成
**输入输出系统由I/O软件和I/O硬件两部分组成**

+ I/O指令
+ 通道指令
####I/O设备与主机的联系方式

1. I/O设备编址方式
	+ 独立编址
	+ 统一编址
2. 设备寻址
	+ 通过接口电路中的设备选择电路选中要交换信息的设备
3. 传送方式
	+ 并行:速度快,要求较多数据线
	+ 串行:速度慢,适合远距离传送
4. 联络方式
	+ 立即响应,无须特殊的联络信号,指令一道立即响应,,,,,,????
	+ 异步工作,采用应答信号联络
	+ 同步工作,采用同步时标联络
5. 连接方式
	+ 总线式
	+ 辐射式
####I/O设备与主机信息传送的控制方式

1. 程序查询
2. 程序中断
3. 直接存储器存取方式(DMA)
4. I/O通道方式
5. I/O处理机方式
(1,2,3详见后边,4,5不具体讲述)

###2.I/O设备
,,,,,,,,,,??????????/
###3.I/O接口
,,,,,,,,,,?????????
###4.程序查询方式
核心问题:**每时每刻不断查询I/O设备是否准备就绪**

####程序查询流程
+ 单个I/O设备的查询流程
	+ 程序流程
		1. 由于传送数据需要占用CPU的寄存器,所以**保护寄存器**内容
		2. 由于传送的往往是一批数据,所以**设置计数值**
		3. 设置欲传送数据的首地址
		4. CPU启动i/o设备
		5. 进入程序查询流程:
			- test:准备就绪,?
				+ 就绪:数据传送
				+ 未就绪:接着test
		6. 完成一次数据传送后,修改主存地址,修改计数值,
		7. 判断计数值,看传送是否完毕
		8. 结束i/o传送
+ 多个I/O设备的查询流程:
	- 按设备在系统中的优先级别进行逐级查询

为完成查询,通常需要3条指令

+ 测试指令
+ 传送指令
+ 转移指令

####程序查询方式的接口电路

+ 输出$\quad CPU\rightarrow i/o接口 \rightarrow i/o设备$
+ 输入$\quad CPU\leftarrow i/o接口 \leftarrow i/o设备$

###5.程序中断方式
**主要介绍i/o中断处理的相关内容**

####程序中断方式的接口电路

#####中断请求触发器和中断屏蔽触发器

1. 中断请求触发器和中断屏蔽触发器
	- 每台外设设置一个中断请求触发器INTR,为1时,表示设备箱CPU提出中断请求
		+ 设备要想提出中断请求,本身必须准备就绪,所以设置一个完成触发器D,表示设备的状态
		+ 当多个中断源同时向CPU提出中断请求时,CPU要坚持一个原则,任何瞬间只能接受一个中断源的请求
		所以每个i/o接口需设置一个屏蔽触发器MASK,当其为1时,表示被屏蔽
		+ CPU在统一的时间-每条指令执行阶段的最后时刻-查询所有设备是否有中断请求
			- (只针对外中断,是这个时刻,内中断肯定要及时响应)
		+ 综上:CPU的中断查询信号将中断请求触发器置1的条件
		(也就是说,外设提出中断,未必会被满足,CPU不一定能将中断请求出发器置1,
		也就是说,中断请求触发器置1,不是说外设提出了中断,而是说CPU满足中断请求)
			+ 设备就绪,即完成触发器为1
			+ 没有被屏蔽,
![接口发出中断请求的条件][0]		
[0]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/INTR.gif
解读:在<u>设备就绪</u>且<u>没有被屏蔽</u>的情况下,当CPU的中断查询信号传来时,接口发出了中断请求信号
(这个信号输出到排队器里边去,参与排队)
#####排队器

2. 排队器:多个中断源同时提出请求时,按优先级高低给予响应,**速度越高优先级越高**
(因为如果不及时响应速度高的设备,它的信息可能会立即消失)
优先权处理可用硬件方法,软件方法,
	+ 软件方法:编写程序查询
	+ 硬件方法:硬件排队器(链式排队器)
		- 在CPU内部设置一个统一的排队器
		![CPU内的链式排队器][1]
		排队原理:
		$INTP_i=\overline{INTP_0}\cdot\overline{INTP_1}\cdots\overline{INTP_{i-1}}\cdot INTR_i\\\
		=\overline{(INTP_{0}+INTP_{1}+\cdots+INTP_{i-1})}\cdot INTR_i,记为\overline{A}\cdot INTR_i\\\
		可见,欲使排队器输出端第i级输出为1,当且仅当A=0\&INTR_i=1,\\\
		A=0,即比第i级高的排队器输出端皆为0,\\\
		反之,只要第i级排队器输出端为1,则\\\
		比第i级优先级级别低的i+1,i+2...级输出皆为0$
		- 在接口电路内分别设置各个设备的排队器
		![分设的链式排队器][2]
		排队原理:
		$INTP_i=INTR_i\cdot INTP_i'\\\
		INTP_i'=\overline{INTR_{i-1}}\cdot NTP_{i-1}' (i>1,INTP_1'=1)\\\
		INTP_i=\overline{(INTR_0+INTR_1+\cdots+INTR_{i-1})}\cdot INTR_i\cdot INTP_1'\\\
		记为\overline{B}\cdot INTR_i \cdot 1\\\
		可见,欲使排队器输出端第i级输出为1,当且仅当B=0\&INTR_i=1,\\\
		B=0,即比第i级高的设备的中断请求输出皆为0,\\\
		反之,只要第i级有中断请求输出,则\\\
		比第i级优先级级别低的i+1,i+2...级排队输出皆为0$
[1]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/chainqueueofCPU.gif
[2]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/chainqueue.gif
#####中断向量地址形成部件(设备编码器)

3. 中断向量地址形成部件(设备编码器)
响应中断就要去执行对应的中断服务程序.CPU如何找到中断服务程序的入口地址,?
	+ 软件查询法:
	+ 硬件向量法:通过向量地址来寻找中断服务程序的入口地址,
	**而向量地址是由硬件电路产生**
		+ 对应于链式排队器的两种放法,中断向量地址形成部件也有两种放法
			- 分散设置在各个接口电路中
			- 放置在CPU内部
		+ 由向量地址寻找中断服务程序入口地址通常也采用两种放法
			- 向量地址内存存放一条无条件转义指令(**向量地址转移**),向量地址送PC
				+ 据白中英说:这种方法允许中断处理程序放在内存中的任何地方,非常灵活
			- 向量地址内存存放入口地址(**设置向量地址表**),访存得到入口地址
			**区别在于一个放的是指令,一个放的是地址**
	+ 分清**向量地址**和中断服务程序入口地址**的区别
#####程序中断接口电路基本组成
电路图
![补图][图5.41]
####i/o中断处理过程

1. CPU响应中断的条件和时间
	+ 条件:'开中断'
	+ 时间:每条指令执行阶段的结束时刻,发出中断查询信号
2. i/o中断处理过程
	+ 中断请求,中断判优,中断响应,中断服务,中断返回
####中断服务程序的流程

1. 保护现场
	+ 保护程序的断点
		- 由中断隐指令完成
	+ 保存通用寄存器和状态寄存器的内容
		- 由中断服务程序完成
2. 中断服务
3. 恢复现场
	+ 用取数指令或出栈指令将保存在存储器或堆栈中的信息送到原来的寄存器中
4. 中断返回
	+ 中断服务程序的最后一条指令,通常是一条中断返回指令,**使pc返回到原程序断点处**

中断服务的细节,单重中断,多重中断的问题,见接下来的Ch8.4

主存和外设交换信息,在程序中断方式中,

+ 相较于程序查询方式,CPU不再踏步等待,实现了CPU和i/o的并行工作,调高了CPU的资源利用率
+ 但是,CPU在处理中断服务程序时,仍需暂停原程序,当高速i/o与主存频繁的交换信息时,采用程序中断方式不断的打断CPU
执行主程序,为此,人们探索出效率更高的DMA控制方式

###6.DMA方式
####DMA方式的特点

不通过CPU交换信息,不暂停CPU,

#####CPU和DMA访存冲突的三种解决方法
由于DMA和CPU共享主存,当出现两者争用主存的冲突时,有三种解决措施

+ 停止CPU访存:
	- DMA接口向CPU发停止信号,要求CPU放弃总线使用权;
	DMA获取总线控制权后,传送数据;
	传送完毕后通知CPU可以使用主存,并交回总线控制权
	- 优点:控制简单;缺点:效率低
	(这什么破方法,,,还不如程序查询吧,,,)
+ 周期挪用
	- i/o设备发出DMA请求时,挪用或窃取总线占有权一个或几个主存周期;不请求时,CPU继续访存
	- 请求DMA时CPU的三种可能状态
		+ 在执行指令,不访存,此时不发生冲突
		+ CPU正在访存,**待存取周期结束后**,CPU让出总线占有权
		+ CPU也正要求访存,**出现冲突**的情况:i/o访存优先于CPU访存;CPU在执行访存的指令插入几个周期,延缓访存
	- 比较适合于i/o设备读写周期大于主存周期的情况
+ DMA与CPU交替访问
	- 将一个CPU周期分成两个周期,,???
	- 不用总线使用权的申请,建立,归还过程
	- 比较适合于CPU工作周期比主存周期长的情况
####DMA接口的功能和组成

#####功能
+ 向CPU申请DMA传送	
+ 处理总线交接
+ 在DAM期间控制数据传送
+ 确定,修改数据传送的起始地址和长度
+ 数据传送介绍时,向cpu给出操作完成的额信号
#####基本组成

+ 主存地址寄存器AR:数据在内存中的首地址,每交换一次数据改变一次
+ 字节数器WC:记录传送数据的总字数;补码表示,原码表示;
+ 数据缓冲寄存器BR:用于暂存每次传送的数据
	- 通常DMA接口与主存之间采用字传送,DMA和设备之间可能是字节或位传送
+ DMA控制逻辑
+ 中断机构:字计数器溢出时,一批数据交换完毕,有溢出信号通过中断机构向CPU提中断请求
+ 设备地址寄存器DAR
####DMA的工作过程

1. 数据传送过程
	+ **预处理**:在DMA开始工作之前,cpu必须给它配置如下信息
		- 给DMA控制逻辑指明数据传送方向,是输入(写主存)还是输出(读主存)
		- 向DMA设备地址寄存器送设备号,启动设备
		- 送主存起始地址到设备地址寄存器
		- 送数据个数到字计数器
	之后cpu继续执行原来的程序,在cpu继续执行原来程序的同时,外设也在准备以待输入进内存的数据
	+ **数据传送**:设备向DMA发请求,DMA向cpu法总线控制请求
	(设备什么时候发请求,?)
		- 数据输入(到主存):
			+ 当设备准备好一个字时将改字读到DMA的BR中
				- **BR已满时,设备向DMA接口发请求DREQ**
			+ DMA接口向CPU申请总线控制权HRQ
			+ CPU发回HLDA信号,表示允许将总线控制权交给DMA接口
			+ ...
		- 数据输出(到外设)
			+ 当DMA的BR已将输出数据送至i/o设备后,
				- **BR已空时,设备向DMA接口发请求**
			+ DMA接口向CPU申请总线控制权HRQ
			+ CPU发回HLDA信号,表示允许将总线控制权交给DMA接口
			+ ...,?
	+ **后处理**:当DMA的中断请求得到响应时,CPU停止原程序的执行,准去执行中断服务程序
	做一些DMA的结束工作包括
		+ 校验送入主存的数据
		+ 是否继续用DMA传送其他数据块
			- 若继续则要再次初始化DMA接口
			- 若不再继续,则要停止外设
		+ 测试传送过程有无错误,
2. DMA接口与系统的连接方式
3. DMA小结	
##Ch8CPU的结构与功能
###4.中断系统