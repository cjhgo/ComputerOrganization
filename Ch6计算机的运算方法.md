viewport:width=device-width,initial-scale=1

目录

[TOC]

##Ch6计算机的运算方法
###无符号数和有符号数
注意,n是指正数的位数,符号位不算

含义的数学表示
通过定义,得到一串数,这一串数称为原/补/反码
####原码表示

####补码表示
补码多表示一位,,
求补码的口诀
求补码的定义
#####整数补码的定义


#####小数补码定义
模2补码
$
\begin{equation}
	[x]_补=
	\begin{cases}
	x,1> x \geqslant 0\\\
	2+x, 0 > x \geqslant -1 (mod 2)
	\end{cases}
\end{equation}
$
#####变形补码
模4的补码
$
\begin{equation}
	[x]_补=
	\begin{cases}
	x,1> x \geqslant 0\\\
	4+x, 0 > x \geqslant -3?? (mod 4)
	\end{cases}
\end{equation}
$
####移码表示
对补码的符号位变号,即可得到对应的移码

###定点运算
####移位运算

只要移位后的结果不溢出,都能正确表示
结果溢出,就相当于高位丢失或低位丢失这样的情况发生
移位相当于 乘法
当计算机中没有乘除法运算线路时,可以用`移位+加法`实现乘除运算
#####算术移位:有符号数的移位

**<u>注意</u>**:算术移位时,第一位是符号位,不要动,对数值位进行移位
算术移位后的空位添补规则
![shift][4]

**如何理解添位规则**

+ 对于正数,其原码,补码,反码全相同,按照乘法规则,补0即可
+ 对于负数
	- 负数原码数值位与真值相同,按照数学规律,补0即可
	(符号位不变)
	- 负数反码数值位与真值相反,既然原码补的是0,反码应该补1
	- 负数的补码:
		+ 分析任意负数的补码(快速求补码的规律:P235)可以发现
		**<u>以负数补码从右往左找到的第一个`1`为界,
		1的左边的数位和负数反码一致
		1的右边的数位(包括1)和负数原码一致</u>**
		由此,得出负数补码添位的规则
		+ 左移时,空位出现在低位,移位后的数的补码的低位和原码相同
		故添加的代码与原码相同,即补0
		+ 右移时,空位出现在高位,移位后的数的补码的高位和反码相同
		故添加的代码与反码相同,即补1

实现算术左移和右移操作的硬件示意图
手工计算移位后的结果是,是按符号位不同,然后移动数值位
硬件实现时,要利用符号位的值		
#####逻辑移位:无符号数的移位
+ 逻辑左移,高位移丢,低位补零
+ 逻辑右移,低位移丢,高位补零

逻辑移位时,每一位都是数值位

用带进位的移位实现算术移位,来避免算术左移时高位丢失
####加法与减法运算
#####(补码)加法运算
**为什么要引入补码,因为用补码表示的两个数在进行加法运算时,可以把符号位与数值位同等处理**
取模,丢掉进位
$
整数:[A]_补+[B]_补=[A+B]_补(mod 2^{n+1})\\\
小数:[A]_补+[B]_补=[A+B]_补(mod 2)\\\
只要结果真值A+B不超过表示范围,\underline{补码的和就是和的补码}
$


#####(补码)减法运算
**为什么要引入补码,因为补码可以消除减法运算**
那么,补码如何消除减法运算,?
>
$作减法运算A-B时,只需先求[-B]_补\\\
而[-B]_补怎么求,?\\\
对[B]_补,连通符号位在内,每位取反,末位加一\\\
(B可正可负)
$
#####补码定点加减法的溢出判断
######一位符号位
+ 加法运算:$正数+正数,负数+负数会产生溢出$
+ 减法运算:$正数-负数,负数-正数会产生溢出$
	- 减法运算是用加法器实现的
**<u>只要实际参加操作的两个数,符号相同,结果又与原操作数的符号不同,即为溢出</u>**

计算机中采用1位符号位判断时,
**用 <u>符号位产生的进位</u> 与 <u>最高有效位产生的进位</u> 进行<u>异或操作</u>,
根据异或的结果,判断是否溢出**
没有进位是0,有进位是1
为什么可以这样做,?
因为本来就是最高位的进位和符号位的运算结果共同决定了最终符号位的情况

|被加数符号|0|0|1|1|
|-|-|-|-|-|
|加数符号|1|0|1|0|
|符号位运算结果|1|0|(1)0|1|
|最高有效位进位0后符号位结果|1|0|(1)0|1|
|最高有效位进位1后符号位结果|(1)0|1|(1)1|(1)0|
|异或结果|

通过这个表格,用来比较
判断溢出的
`异或判断溢出`的方法 和 `符号位相同,结果又与原操作数不同`的方法
溢出时,才会有 异或 结果为1

关系,,
两个不同符号的数相加不可能溢出
两个相同符号的数相加,才有可能溢出;
是否溢出,看最高符号位的进位进一步如何影响 符号位


######两位符号位
用两位符号位的补码,即变形补码作加法
,2位符号位同数值部分一起参与运算
最高符号位产生的进位自动丢失(因为取2^2的模)
溢出判断原则

+ 当两位符号位不同时,表示溢出
+ 否则,无溢出
+ 无论是否发生溢出,高位符号位都代表(保存着)运算结果的真值的符号
	- 因此可以通过高位符号位来判断是
	正溢出,还是负溢出

采用双符号位时,只需保存一位符号位即可
因为任何正确的数,两个符号位总是相同的
硬件运算时,把保存的这一位符号位送到加法器的双符号位的输入端
####乘法运算
#####笔算乘法的改进
#####原码乘法
######原码一位乘
######原码两位乘
#####补码乘法
######补码一位乘
######补码比较法
######补码两位乘
####除法运算
#####原码除法
#####补码除法
###数的定点表示和浮点表示
在计算机中,小数点不用专门的器件表示,而是按照约定的方式标出
共有两种方法表示小数点的存在,即定点表示和浮点表示
####定点表示
+ 纯小数:小数点位于数符位和第一数值位之间
+ 纯整数:小数点位于数值位之后

处理非纯小数
处理非纯整数
都要乘上一个比例因子
####浮点表示
$$N=S \times r^j\\\
S:尾数,决定了表示精度\\\
r:基数\\\
j:阶码,决定了表示范围$$


**<u>浮点数的位数确定后,合理分配阶码和尾数的位数直接影响
浮点数的表示范围和精度</u>**


+ 为了提高数据精度,以及便于浮点数的比较
规定**<u>浮点数的尾数用纯小数形式</u>**
+ **<u>规格化数:尾数最高位为1的浮点数</u>**
浮点数表示成规格化形式后,精度最高
+ 浮点数的表示形式
![floatpoint][0]
	

- m位的阶码表示范围


	
+ 浮点数的表示范围
	+ 浮点数能表示的
	$最大的正数A (1-2^{-n})\times 2^{(2^m-1)}\\\
	最小的正数B 2^{-n}\times 2^{-(2^{m}-1)}\\\
	最大的负数-B\\\
	最小的负数-A$
		- 规格化后,浮点数能表示的A不变,B变
	- 不是能表示的最小的数,是最小的正数
	浮点数当然能表示零,但是
		+ $\underline{在0和B ,及-B到0之间,有很多数无法用浮点数表示}$
			- 因为它们的阶码小于最小阶码
			这叫`下溢`
			**产生下溢时机器,机器将尾数各位强置为零,按机器零处理**
				+ 举例比如
				阶码最小是-12,即小数点最多左移12位
				$0$
				而一个数要小数点左移-15,即阶码为-15 < -12,
				产生下溢
					- $机器能表示的最小正数是0.\underbrace{000...001}\_{n}\\\
					那么0.\underbrace{000...00001}\_{>n,比如n+5},就没法表示$
		+ $\underline{在B和+\infty,及-\infty到-B之间,有很多数无法用浮点数表示}$
			- 因为他们的阶码大于最大阶码
			这叫`上溢`
			**产生上溢时机器停止运算,进行中断溢出处理**
				+ 举例比如

![floatoverflow][3]				

+ 浮点数的规格化
	- $尾数左移一位相当于乘了2,阶码部分要乘2^{-1}抵销,即\\\
	尾数左移,阶码减一\\\
	尾数右移一位相当于乘了2^{-1},阶码要乘2抵销,即\\\
	尾数右移,阶码加一$
		+ **<u>区分尾数移动和,小数点移动</u>**
	- 规格化后,浮点数能表示的最小正数是
	$0.1000\cdots \times 2^{-Max_{阶码}} = ...$
	最大负数相应变化,最大正数和最小负数不变
####定点数和浮点数的比较
![floatsample][1]
$$阶符,阶码数值部分;数符.尾数数值部分$$
**十进制分数怎样化成二进制小数,快速**
$ \frac{53}{512},并不能主观的看出来\\\
要义:\times \frac{256}{256},256怎样来的,512的一半\\\
= \frac{53}{512} \times \frac{256}{256}\\\
= \frac{53}{256} \times \frac{256}{512}\\\
= \frac{53}{256} \times \frac{1}{2}\\\
= ...\\\
即,乘 \frac{1}{2}
当算到了 \frac{21}{32}时,这样算\\\
= \frac{16+4+1}{32}$

**关于机器零**

+ 机器零有两种情况
	- 尾数为0
		+ 尾数为0,阶码无论多少,这个数都是0
	- (尾数虽不为零),但是产生了下溢
		+ 阶码小于或等于最小阶码,等于也算,,
+ 机器零的写法
	- 尾数补码表示,阶码补码表示时,
	机器零这么写:$1,000..0;0.000...0$
	- 尾数补码表示,阶码移码表示时,
	机器零这么写:$0,000...0;0.000...0$
		+ 这种写法的机器零
		是全零,有利于简化机器的判零电路
####IEEE754
![IEEE754][2]
IEEE754的短实数和长实数的尾数规格化有一位隐藏位
临时实数不采用隐藏位方案
举例
$178.125_{10}\\\
=1011 0010.001\\\
\overset{按照之前的约定}=0.1011 0010 001 \times 2^{-1000_2},尾数是一个纯小数\\\
\overset{采用隐藏位}= 1.011 0010 001 \times 2^{-111_2},尾数非纯小数$

二进制的IEEE754 如何表示 成十进制/二进制科学记数法转换为十进制科学记数法
$
log\_2 10 = 3.3...\\\
10^y= (2^{log\_2 10})^y = 2^{3.3\*y}\\\
2^x= (10^{log\_{10}2})^x = 10^{0.3\*x}
$
**10进制科学记数法常常这样表示$a \times 10^ b= aEb$**
(c语言中的实数的指数形式)
IEEE754能表示的最小正数是$2^{-149},写为以10为基的形式是1.4\times10^{-45}$
$0\quad\quad 000\quad 0000 \quad\quad 0000\quad 0000\quad 0000\quad 0000\quad 0000\quad 0001$
###浮点四则运算
####浮点加减运算
**补码表示的尾数的左移,右移要按照
补码算术移位添位规则来补空位**
即,`符号位不动;正数补0;负数算术右移,空出的高位补1;负数算术左移,空出的低位补0`


1. 对阶:**小阶向大阶看齐**
	+ 小阶向大阶看齐,小阶要变大,尾数就要变小
	尾数变小就要右移
		- **尾数右移可能发生数码丢失,影响精度**
	+ 如果让大阶向小阶看齐,大阶变小,大阶的尾数就要变大
	即要左移,左移之后得到的尾数就不再是纯小数了
	所以,小阶向大阶看齐
2. 尾数求和
	+ 按定点数加减法运算即可
3. 规格化:$规格化要求尾数是这样的形式:\pm.1....\\\
即 \frac{1}{2} \leqslant |S| \leqslant 1$
	+ **如果采用双符号位的补码**
	$S>0, [S]_补=00.1....\\\
	S<0,[S]_补=11.0.....
	可见,当尾数的最高数值位和符号位不同时,即为规格化形式$
		- 两种特殊情况
			+ $S= -\frac{1}{2},[S]_补=11.100...\\\
			按规则,规定,用补码表示的-\frac{1}{2}不是规格化数$
			+ $S= -1,[S]_补=11.000...\\\
			按规则,规定,用补码表示的-1是规格化数$
	+ 结果按规则不是规格化数时,需要规格化
		- 左规:符号位和最高数值位相同不符合规则
			+ 正尾数$00.0....要规格化,\\\
			应该左移让从左起的第一个非零位移动到最高位$
				- 正数右移补零,所得尾数还是非规格化的所以不能右移
			+ 负尾数$11.1....要规格化\\\
			应该让从左起的第一个非1位移动到最高位$
				- 高位的1取模之后自然舍去
				- 负数右移补1,所得尾数还是非规格化的所以不能右移
		- 右规:尾数发生溢出,尾数之和绝对值大于1,
		表现为双符号位两位值不同$01.XXXXXXX或10.XXXXXXX$
			+ 尾数右移,阶码加一
			**双符号位尾数,按什么规则右移,?!!!**
4. 舍入:对阶和右规过程中,尾数右移低位丢失,引起误差,影响精度
为此可用舍入法来提高尾数的精度
	+ `0舍1入法`
	右移时,被移去的最高数值位为0,则舍去
	被移去的最高数值位为1,则在尾数的末位加1
		- 什么叫被移去的最高数值位,?
		右移时,可能从最低位往左数,可能有多位被移去,在这些位中,最高的,也就是最左边的
	+ `恒置1法`
	不论丢掉的最高数值位是`1`还是`0`,都使右规后的尾数的末位置为1
5. 溢出判断
一般说浮点溢出都是说上溢
	+ 下溢时的阶码
	由于补码表示,阶码最小时,数位是这样的$11.0000000...0$
		- 由于$补码表示的-\frac{1}{2},[-\frac{1}{2}]_补=11.100...\\\
		不是规格化数,所以\\\
		虽然最小的正数的尾数是1/2,但是最大负数的尾数不是-1/2\\\
		\vdots$

####浮点乘除法运算



###算术逻辑单元

http://segmentfault.com/a/1190000004090283
http://w3schools.invisionzone.com/index.php?showtopic=48625
https://www.quora.com/Why-is-0-1+0-2-not-equal-to-0-3-in-most-programming-languages
http://stackoverflow.com/questions/588004/is-floating-point-math-broken
http://stackoverflow.com/questions/5852056/why-does-alert321-alert-false
http://www.exploringbinary.com/hexadecimal-floating-point-constants/
http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
http://floating-point-gui.de/

https://www.ics.uci.edu/~eppstein/161/960227.html


https://www.baidu.com/s?wd=%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E5%86%8D%E6%95%A3%E5%88%97%E6%B3%95%20%E6%9F%A5%E6%89%BE%E5%A4%B1%E8%B4%A5&rsv_spt=1&rsv_iqid=0xdcdfaf9100023aa7&issp=1&f=8&rsv_bp=0&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_sug3=31&rsv_sug1=17&sug=%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E5%86%8D%E6%95%A3%E5%88%97%E6%B3%95&rsv_n=1&rsv_t=af664Tpw7e%2Fy%2F9ProyMdLm3oRmdBPbz7RtggOWpIkwPGbu9hTq4rNPoIuANECfyUlEj3&rsv_sug2=0&inputT=13206&rsv_sug4=13206

http://www.cskaoyan.com/thread-160179-1-1.html

[0]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/floatpoint.gif
[1]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/floatsample.gif
[2]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/IEEE754.gif
[3]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/floatoverflow.gif
[4]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/shift.gif