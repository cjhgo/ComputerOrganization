viewport:width=device-width,initial-scale=1

目录

[TOC]

#[计算机组成原理](...)
##Ch7指令系统
指令系统的分类
常见寻址方式
指令格式
设计指令系统时应考虑的各种因素
###1.机器指令
####指令的一般格式
**$|\underline{\overline{操作码字段}}|\underline{\overline{操作数的地址码字段}}|$**
操作数的地址码
指令中存放的是操作数的地址码,通过地址码访存得到操作数
**操作数是目的,地址码是手段**


#####操作码
操作码用来指明该指令所要完成的操作

+ 位数反应机器允许的指令条数
+ 固定长度与可变长度的问题,,????????
扩展操作码技术
#####地址码
地址码用来指出该指令源操作数的地址,结果的地址,下一条指令的地址

+ 四地址指令
$|\underline{\overline{OP}}|\underline{\overline{A_1第一操作数地址}}|
\underline{\overline{A_2第二操作数地址}}|
\underline{\overline{A_3结果存放地址}}|\underline{\overline{A_4下一条指令地址}}|$
	- 四次访存
		+ 取指令一次
		+ 取第一操作数一次
		+ 取第二操作数一次
		+ 存结果一次	
+ 三地址指令$|\underline{\overline{OP}}|\underline{\overline{A_1}}|\underline{\overline{A_2}}|
\underline{\overline{A_3}}|$
	- 把后续指令地址隐含在程序计数器PC中,省去$A_4字段$,直接寻址范围扩大
	- 依然是四次访存
+ 二地址指令$|\underline{\overline{OP}}|\underline{\overline{A_1}}|\underline{\overline{A_2}}|$
	- $A_1或A_2$既用来表示操作数地址,也用来表示结果存放地址,省去$A_4字段$,直接寻址范围扩大
	- $(A_1)OP(A_2) \rightarrow A_1/A_2$:4次访存
	- $(A_1)OP(A_2) \rightarrow ACC$:3次访存
		- 存结果不用访存
+ 一地址指令$|\underline{\overline{OP}}|\underline{\overline{A_1}}|$
	- 用ACC既存放操作数,也用来存放运算结果,省去一个操作数字段,直接寻址范围扩大
	- $(A_1)OP(ACC) \rightarrow ACC$:2次访存
		- 取指令访存一次
		- 取操作数访存一次
+ 零地址指令$|\underline{\overline{OP}}|$
	- 操作数地址隐含在退栈指针中

**结论**:用硬件资源承担地址码可扩大寻址范围

操作码是寄存器的情况,不用访存	
####指令字长

+ $操作码长度+操作数地址长度\times操作数地址个数=指令长度$
+ 指令字长:操作码+操作数位数
+ 机器字长:CPU内寄存器的位数
+ 存储字长:基本存储单元一个字的位数
###2.操作数类型和操作类型
####操作数类型

+ 地址
+ 数字
+ 字符
+ 逻辑数据
####数据在存储器中的存放方式

+ 边界对齐的问题
+ 两种字节序的问题
####操作类型

+ 数据传送
+ 算术逻辑操作
+ 移位
+ 转移
	- 无条件转移
	- 条件转移
	- 调用与返回
		+ 过程调用
		+ 系统调用
		+ 子程序调用
	- 陷阱与陷阱指令
+ 输入输出
+ 其他:等待,停机,空操作,开中断,关中断,置条件码,.....
+ 非数值处理指令:字符串传送,字符串比较,字符串查询,...
###3.寻址方式
寻址方式:确定本条指令的数据地址以及下一条将要执行的指令地址的方法
####指令寻址
+ 顺序寻址:程序计数器PC加1,自动形成下一条指令的地址
+ 跳跃寻址:通过转移类指令实现
####数据寻址
在指令中设置一字段指明属于哪一种寻址方式
指令的地址码往往不代表操作数的真实地址,称为形式地址,记为A
操作数的真实地址称为有效地址,记为EA,由**寻址方式和形式地址**共同确定

#####1.立即寻址:立即数
操作数本身就在指令字内
立即数,立即寻址特征#

+ 优点,只要取出指令就立即获得操作数,指令执行阶段不必访存
+ 缺点,位数限制了立即数的范围
#####2.直接寻址:EA=A
形式地址就是真实地址

+ 位数限制了寻址范围
#####3.隐含寻址:不显式给出地址码
指令不明显的给出操作数地址,操作数地址隐含在操作码或寄存器中
#####4.间接寻址EA=(A)
形式地址指出操作数有效地址所在的存储单元地址

+ 优点1:扩大了操作数的寻址范围,因为形式地址位数通常小于指令字长,而存储字长可与指令字长相等,能表示更高的地址
	+ 多次间址,可以用存储字的首位来标识,同时首位就不再是EA的组成部分
+ 优点2:便于编制程序.
	- 通过间址,虽然每次返回到不同的地址单元但可以用相同的指令表示,进而这样的指令可以写成子程序
+ 缺点:要两次或多次访存
#####5.寄存器寻址:EA=R_i
地址码给出寄存器编号,操作数在寄存器中
#####6.寄存器间接寻址:EA=(R_i)
地址码给出寄存器编号,真实地址在寄存器中
比间接寻址少访存一次
#####7.基址寻址:EA=A+(BR)
有效地址=形式地址+基址寄存器中的内容(基地址)
基址寄存器
	- 隐式基址寄存器,专用基址寄存器,用户不必明显指出,由指令寻址特征位反映出
	- 显式基址寄存器,用户明确指出通用寄存器中的某个寄存器作基址寄存器
+ 可扩大操作数的寻址范围:首地址+偏移量	
#####8.变址寻址:EA=A+(IX)
有效地址=形式地址+变址寄存器内容之和

+ 基址寻址主要用于为程序或数据分配存储空间,故基址寄存器内容通常由操作系统或管理程序确定,
	- 程序执行过程中,基址寄存器不变,A可变
+ 变址寻址中,变址寄存器内容由用户设定,
	- 程序执行过程中,A不变,变址寄存器其值可变,
	- 主要用于处理**数组问题**:A为首地址,IX是不断变化的下标
#####9.相对寻址:EA=(PC)+A
用于转移类指令,**转移地址不固定**,随PC值变化而变

+ 对应编写**浮动程序**特别有利,
	- 程序无论在主存哪段区域都可以正确运行
#####不同寻址方式的配合使用
+ 基址变址寻址
+ 相对间址寻址,,,
#####10.堆栈寻址
+ 堆栈用寄存器组来实现,硬堆栈
+ 堆栈用主存一部分空间做堆栈,软堆栈

堆栈寻址可以看做是一种隐含寻址,因为它的操作数是由堆栈指针隐式给出的
堆栈寻址也可以看做是一种间接寻址,如果SP这个堆栈指针是个寄存器的话,SP存放在操作数的有效地址
###5.RISC技术

LI7.2
7.4-7.7