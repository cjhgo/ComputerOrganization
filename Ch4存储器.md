viewport:width=device-width,initial-scale=1

目录

[TOC]
#[计算机组成原理](...)
##Ch3存储器
主存储器的分类;
工作原理;
组成方式;
与CPU的联系;
cache;
disk;
**用不同存储器组成具有层次结构的存储系统**
###1.概述
####存储器分类

+ 按存储介质
	- 半导体存储器:电源消失,信息丢失
		+ 双极型TTL:高速
		+ MOS半导体:高集成度
	- 磁表面存储器
	- 磁芯存储器:体积大,工艺复杂,渐渐废除
	- 光盘存储器
+ 按存取方式
	- 随机存储器:RAM
		+ 任何一个单元都可以随机存取,存取时间和物理位置无关
		+ 信息存储原理
			- 静态RAM:用触发器寄存信息
			- 动态RAM:用电容充放电寄存信息
	- 只读存储器:ROM:内容只能读,不能写
	- 串行访问存储器:存取时间和物理位置有关
		+ 顺序存储器:磁带,无论信息在哪个位置,都要从头开始顺序寻找
		+ 直接存储器:磁盘,先直接访问,后串行访问
+ 按在计算机中作用分
	+ 主存
	+ 缓存
	+ 辅存
####存储器的层次结构

+ 缓存-主存层主要解决CPU和主存速度不匹配的问题
	- 主存和缓存之间的数据调动是由硬件自动完成的
+ 主存-辅存层主要解决的是存储系统容量的问题
	- 主存和辅存之间的数据调动是由硬件和操作系统共同完成的
###2.存储器
MAR,MDR制作在CPU芯片中,存储芯片和cpu芯片通过总线连接


####主存中存储单元地址的分配

**存储单元**是什么,课本P13??
存储体由许多存储单元组成,存储单元又包含若干个存储元件
存储单元对应存储字长,--->代表一个字

+ 按字节寻址
+ 按字寻址
####主存的技术指标

如何理解存取周期,?

+ 存储容量
	- 用位bit表示:存储单元个数x存储字长
	- 用字节byte表示:存储单元个数x存储字长/8
+ 存储速度,由存取时间和存取周期来表示
	- 存取时间:存储器的访问时间,启动一次存储器操作到完成该操作所需的全部时间
	- 存取周期:存储器进行连续两次独立的存储器操作所需的最小间隔时间
	(通常存取周期大于存取时间)
+ 存储器带宽:单位时间内存储器存取的信息量
	- 存取周期为500ns,每个存取周期可以访问16位,则带宽为32 M 位/秒
####半导体存储芯片

+ 基本结构:读写电路,译码驱动,存储矩阵
	- 数据线:位数和芯片可读/写数据位数有关
	- 地址线:和芯片,?存储单元个数?有关
	- 控制线:读写控制,片选控制
+ 译码驱动方式
	- 线选法
	- 重合法
####随机存取存储器,,,,????

时序图中反映了读写时间和读写周期的区别

$SRAM,DRAM,ROM$

+ 基本单元电路
+ 芯片
+ 读时序
+ 写时序
####存储器和CPU的连接

1. 存储容量的扩展
	+ 字扩展
	+ 位扩展
	+ 字位扩展
2. 存储器和cpu的连接
	+ 地址线的连接
	+ 数据线的连接
	+ 读写命令线的连接
	+ 片选线的连接
	+ 合理选择芯片类型,是RAM还是ROM;**考虑芯片数量时,要尽量让连线简单**
####存储器的校验,汉明码
检错编码与纠错编码,[计算机网络]

????????????
####提高访存速度的措施(并行技术)
寻找高速元件,采用层次结构+调整主存结构

**调整主存结构**

1. 双模口RAM:两个彼此独立的读写口,每个读写口都有一套自己的地址寄存器和译码电路,可以并行地独立工作.
	+ 读写冲突:忙标志
2. 单体多字系统
3. 多体并行系统:采用多体模块组成的存储器,每个模块有相同的容量和存取速度,
**各个模块有独立的MAR,MDR,地址译码,驱动电路,读写电路**,能并行工作能交叉工作
	+ 高位交叉编址多体存储器
		- 顺序存储:程序在体内顺序存放,一个体存满后存入下一个体
	+ 低位交叉编址多体存储器
		- 交叉存储:程序连续存放在相邻的体中
当CPU连续读取n个字时,
对于高位交叉编址,由于这n个字都在同一个体中,所以只能依次访问,即只能等到第i个字读取完成后再能接着读下一个字
对于低位交叉编址,由于这n个字在相邻(不同)的体中,所以在访问第i个字所在的体时,也可以访问第i+1个字所在的体
那么,在时间上怎样安排多体访问的顺序呢,?
访问第i个字 即向第i个字所在的体发负脉冲启动工作信号,
那么,可以同时启动各个体吗,?显然不行,同时启动它们的数据就同时送到了总线上竞争传送
所以,启动第i个体后,等待一个总线传输周期,再启动下一个体,这样,
($记存取周期为T,总线传输周期为\tau$)

![四体低位交叉编址存储器流水线工作示意图][0]
[0]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/fourbodyaddress.gif
**文字说明**
$
在t=0时,启动第i个体,\\\
在t=\tau时启动第i+1个体\\\
在t=T时,第i个体上的数据送到总线上\\\
在t=T+\tau时第i个体上的数据经总线传输完毕,\\\
\quad从另一个角度t=\tau+T即第i+1个体已经经历了一个存取周期,数据刚好送到总线上\\\
在t=\tau+\tau时,启动第i+2个体\\\
在t=\underbrace{\tau+ \cdots +\tau}_{n-1}时,启动第i+n-1个体\\\
在t=\underbrace{\tau+ \cdots +\tau}_n时,启动第i+(n)\%n=i个体$


此时有结论	
(前提条件:体的存储字长和数据总线宽度一致,这样取出的数据一个总线传输周期刚好运送完毕)

+ $n体并行系统,连续读取n个字所需时间t_1=T+(n-1)\tau$
	- 我所理解的是,这个读取是指从内存中读出放到总线上,因为最后一个若要送到CPU还有在经历一个总线传输周期
+ $T=n\tau,:因为连续读取时,两次读取第i个体之间相隔了n\tau的时间$

对于高位交叉编址存储器,连续读取n个字,没读一个字都要等待上一个字,所以所需时间$t_2=nT$

**多体模块存储器的存控**
存控用来合理安排各部件请求访问顺序以及控制读写

+ 排队器
+ 存控标记触发器
+ 节拍发生器
+ 控制线路

**高性能存储芯片**
,,,??????????
###3.cache高速缓冲存储器
**为了避免CPU和i/o设备争抢访存,可在CPU和主存之间加一级缓存**
程序访问的局部性原理
(一般cache采用SRAM制作)

**cpu和cache之间一次传送一个字,cache和主存之间一次传送一个字块**
####cache的工作原理
+ 主存和cache分成大小相同的块;每个块有各自的块号
	- (从0开始编号)
+ 主存容量大块数多,cache容量小块数少;映射:根据主存地址得到cache地址
	- $主存块号m位,块数:2^m=M;cache块号c位,块数2^c=C;\\\
	块内字数B=2^b,块长;$
+ 访存时
	- 地址映射变换
		- 命中:所需的字已在cache之中
			+ 读:直接访问cache,将所需的字送入CPU
			+ 写
				- 写直达法
				- 写回法
		- 不命中:所需的字不在cache之中
			+ 读写也有不同,,,详见具体介绍
			+ cache未满:调入cache
			+ cache已满:替换cache
				- 替换策略
					+ FIFO
					+ LRU
					+ 随机法
+ 衡量cache的效率
	- 命中率:$h=\frac{N_c}{N_c+N_m}$
	- 平均访问时间:$t_a=ht_c+(1-h)t_m$
	- 访问效率:$e=\frac{t_c}{t_a}\times 100\%$
	- 影响因素,,,,?????曲线关系
		+ 块长
		+ 容量
	

####cache读写操作

+ 读
![cache读数操作流程][1]
[1]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/cacheread.gif
+ 写
	- 写直达法:写命中时数据既写入cache又写入主存
		- 保证了数据始终一致,增加了访存次数
	- 写会法:写操作/写命中时,数据只写入cache;**当cache被替换时,把数据写回主存**
		+ 会造成数据不一致;需要设立标志位
	- 写一次法:写回法+第一次命中时同时写入主存


####cache的改进

+ 单一缓存和两级缓存
+ 统一缓存和分立缓存
	- 分立缓存:指令和数据分别存放在两个缓存之中
		+ 哈佛结构计算机采用分立缓存
		+ 超前控制需要分立缓存
####主存地址映射方法
#####直接映射
$i=j \quad mod \quad 2^c,i为缓存块号,j为主存块号$
**每个缓存块对应若干个主存块,每个主存块对应一个缓存块**
由于每个缓存块对应多个主存块,需要标记位来标记对应的是具体哪一块内存块
标记位:每一个缓存块都有一个标记位换句话说,同一个缓存块的字对应的内存块的标记相同;
$2^c个,每个都是t位$

由于每个内存块只**固定**地对应一个缓存块,就显得很不灵活和低效,因为即使缓存内有空余位置时也无法利用
如果程序恰好要重复访问对应同一缓存块的主存块,就会不停替换
#####全相联映射
缓存块和内存块任意映射

逻辑电路复杂,成本高

#####组相联映射
把cache分成Q组,每组R块
$i=j\quad mod \quad Q$
按上式,把每个主存块映射到第i组,具体映射到第i组内的哪一块,是任意的
克服了直接映射不灵活的缺点;也避免了全相联映射过于复杂的缺点
#####地址格式

+ Direct Mapped Cache
![DirectMappedCache][2]
[2]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/DirectMappedCache.gif
+ Fully Associative Cache
![FullyAssociativeCache][3]
[3]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/FullyAssociativeCache.gif
+ Set Associative Cache
![SetAssociativeCache][4]
[4]:http://cjhgo.sinaapp.com/CS/ComputerOrganization/images/SetAssociativeCache.gif
####替换策略


